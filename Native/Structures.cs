/*
 * MemorySharp Library
 * http://www.binarysharp.com/
 *
 * Copyright (C) 2012-2014 Jämes Ménétrey (a.k.a. ZenLulz).
 * This library is released under the MIT License.
 * See the file LICENSE for more information.
*/

using System;
using System.Runtime.InteropServices;
using Binarysharp.MemoryManagement.RemoteProcess.Internals;

namespace Binarysharp.MemoryManagement.Native
{
    /// <summary>
    ///     Contains the flash status for a window and the number of times the system should flash the window.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct FlashInfo
    {
        /// <summary>
        ///     The count
        /// </summary>
        public uint Count;

        /// <summary>
        ///     The flags
        /// </summary>
        public FlashWindowFlags Flags;

        /// <summary>
        ///     The HWND
        /// </summary>
        public IntPtr Hwnd;

        /// <summary>
        ///     The size
        /// </summary>
        public int Size;

        /// <summary>
        ///     The timeout
        /// </summary>
        public int Timeout;
    }

    /// <summary>
    ///     Contains information about a simulated message generated by an input device other than a keyboard or mouse.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct HardwareInput
    {
        /// <summary>
        ///     The message generated by the input hardware.
        /// </summary>
        public int Message;

        /// <summary>
        ///     The high-order word of the lParam parameter for <see cref="Message" />.
        /// </summary>
        public short WParamH;

        /// <summary>
        ///     The low-order word of the lParam parameter for <see cref="Message" />.
        /// </summary>
        public short WParamL;
    }

    /// <summary>
    ///     Used by <see cref="SafeNativeMethods.SendInput" /> to store information for synthesizing input events such as
    ///     keystrokes, mouse movement, and mouse clicks.
    /// </summary>
    [StructLayout(LayoutKind.Explicit)]
    public struct Input
    {
        /// <summary>
        ///     The information about a simulated hardware event.
        /// </summary>
        [FieldOffset(sizeof (int))] public HardwareInput Hardware;

        /// <summary>
        ///     The information about a simulated keyboard event.
        /// </summary>
        [FieldOffset(sizeof (int))] public KeyboardInput Keyboard;

        /// <summary>
        ///     The information about a simulated mouse event.
        /// </summary>
        [FieldOffset(sizeof (int))] public MouseInput Mouse;

        /// <summary>
        ///     The type of the input event.
        /// </summary>
        [FieldOffset(0)] public InputTypes Type;

        /// <summary>
        ///     Constructor that specifies a type.
        /// </summary>
        /// <param name="type">The type if the input event.</param>
        public Input(InputTypes type) : this()
        {
            Type = type;
        }
    }

    /// <summary>
    ///     Contains information about a simulated keyboard event.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct KeyboardInput
    {
        /// <summary>
        ///     An additional value associated with the keystroke. Use the GetMessageExtraInfo function to obtain this information.
        /// </summary>
        public IntPtr ExtraInfo;

        /// <summary>
        ///     Specifies various aspects of a keystroke.
        /// </summary>
        public KeyboardFlags Flags;

        /// <summary>
        ///     A hardware scan code for the key.
        ///     If <see cref="Flags" /> specifies KEYEVENTF_UNICODE, wScan specifies a Unicode character which is to be sent to the
        ///     foreground application.
        /// </summary>
        public short ScanCode;

        /// <summary>
        ///     The time stamp for the event, in milliseconds. If this parameter is zero, the system will provide its own time
        ///     stamp.
        /// </summary>
        public int Time;

        /// <summary>
        ///     A virtual-key code. The code must be a value in the range 1 to 254. If the <see cref="Flags" /> member specifies
        ///     KEYEVENTF_UNICODE, wVk must be 0.
        /// </summary>
        public Keys VirtualKey;
    }

    /// <summary>
    ///     Describes an entry in the descriptor table. This structure is valid only on x86-based systems.
    /// </summary>
    /// <remarks>This is a simplified version of the original structure.</remarks>
    [StructLayout(LayoutKind.Sequential)]
    public struct LdtEntry
    {
        /// <summary>
        ///     High bits (24–31) of the base address of the segment.
        /// </summary>
        public byte BaseHi;

        /// <summary>
        ///     The low-order part of the base address of the segment.
        /// </summary>
        public ushort BaseLow;

        /// <summary>
        ///     Middle bits (16–23) of the base address of the segment.
        /// </summary>
        public byte BaseMid;

        /// <summary>
        ///     Values of the Type, Dpl, and Pres members in the Bits structure (not implemented).
        /// </summary>
        public byte Flag1;

        /// <summary>
        ///     Values of the LimitHi, Sys, Reserved_0, Default_Big, and Granularity members in the Bits structure (not
        ///     implemented).
        /// </summary>
        public byte Flag2;

        /// <summary>
        ///     The low-order part of the address of the last byte in the segment.
        /// </summary>
        public ushort LimitLow;
    }

    /// <summary>
    ///     Contains information about a range of pages in the virtual address space of a process. The VirtualQuery and
    ///     <see cref="SafeNativeMethods.VirtualQueryEx" /> functions use this structure.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct MemoryBasicInformation
    {
        /// <summary>
        ///     The size of the region beginning at the base address in which all pages have identical attributes, in bytes.
        /// </summary>
        public readonly int RegionSize;

        /// <summary>
        ///     A pointer to the base address of a range of pages allocated by the VirtualAlloc function. The page pointed to by
        ///     the BaseAddress member is contained within this allocation range.
        /// </summary>
        public IntPtr AllocationBase;

        /// <summary>
        ///     The memory protection option when the region was initially allocated. This member can be one of the memory
        ///     protection constants or 0 if the caller does not have access.
        /// </summary>
        public MemoryProtectionFlags AllocationProtect;

        /// <summary>
        ///     A pointer to the base address of the region of pages.
        /// </summary>
        public IntPtr BaseAddress;

        /// <summary>
        ///     The access protection of the pages in the region. This member is one of the values listed for the AllocationProtect
        ///     member.
        /// </summary>
        public MemoryProtectionFlags Protect;

        /// <summary>
        ///     The state of the pages in the region.
        /// </summary>
        public MemoryStateFlags State;

        /// <summary>
        ///     The type of pages in the region.
        /// </summary>
        public MemoryTypeFlags Type;
    }

    /// <summary>
    ///     Contains information about a simulated mouse event.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct MouseInput
    {
        /// <summary>
        ///     The absolute position of the mouse, or the amount of motion since the last mouse event was generated, depending on
        ///     the value of the <see cref="Flags" /> member.
        ///     Absolute data is specified as the x coordinate of the mouse; relative data is specified as the number of pixels
        ///     moved.
        /// </summary>
        public int DeltaX;

        /// <summary>
        ///     The absolute position of the mouse, or the amount of motion since the last mouse event was generated, depending on
        ///     the value of the <see cref="Flags" /> member.
        ///     Absolute data is specified as the y coordinate of the mouse; relative data is specified as the number of pixels
        ///     moved.
        /// </summary>
        public int DeltaY;

        /// <summary>
        ///     An additional value associated with the mouse event. An application calls GetMessageExtraInfo to obtain this extra
        ///     information.
        /// </summary>
        public IntPtr ExtraInfo;

        /// <summary>
        ///     A set of bit flags that specify various aspects of mouse motion and button clicks.
        ///     The bits in this member can be any reasonable combination of the following values.
        ///     The bit flags that specify mouse button status are set to indicate changes in status, not ongoing conditions.
        ///     For example, if the left mouse button is pressed and held down, <see cref="MouseFlags.LeftDown" /> is set when the
        ///     left
        ///     button is first pressed, but not for subsequent motions. Similarly, <see cref="MouseFlags.LeftUp" /> is set only
        ///     when the button is first released.
        ///     You cannot specify both the <see cref="MouseFlags.Wheel" /> flag and either <see cref="MouseFlags.XDown" /> or
        ///     <see cref="MouseFlags.XUp" /> flags
        ///     simultaneously in the dwFlags parameter, because they both require use of the mouseData field.
        /// </summary>
        public MouseFlags Flags;

        /// <summary>
        ///     If <see cref="Flags" /> contains <see cref="MouseFlags.Wheel" />, then mouseData specifies the amount of wheel
        ///     movement.
        ///     A positive value indicates that the wheel was rotated forward, away from the user; a negative value indicates that
        ///     the wheel was rotated backward, toward the user.
        ///     One wheel click is defined as WHEEL_DELTA, which is 120.
        ///     Windows Vista: If dwFlags contains <see cref="MouseFlags.HWheel" />, then dwData specifies the amount of wheel
        ///     movement.
        ///     A positive value indicates that the wheel was rotated to the right; a negative value indicates that the wheel was
        ///     rotated to the left.
        ///     One wheel click is defined as WHEEL_DELTA, which is 120.
        ///     If dwFlags does not contain <see cref="MouseFlags.Wheel" />, <see cref="MouseFlags.XDown" />, or
        ///     <see cref="MouseFlags.XUp" />, then mouseData should be zero.
        ///     If dwFlags contains <see cref="MouseFlags.XDown" /> or <see cref="MouseFlags.XUp" />, then mouseData specifies
        ///     which X buttons were pressed or released.
        ///     This value may be any combination of the following flags.
        ///     XBUTTON1 = 0x1
        ///     XBUTTON2 = 0x2
        /// </summary>
        public int MouseData;

        /// <summary>
        ///     The time stamp for the event, in milliseconds. If this parameter is 0, the system will provide its own time stamp.
        /// </summary>
        public int Time;
    }

    /// <summary>
    ///     The <see cref="Point" /> structure defines the x and y coordinates of a point.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct Point
    {
        /// <summary>
        ///     The x-coordinate of the point.
        /// </summary>
        public int X;

        /// <summary>
        ///     The y-coordinate of the point.
        /// </summary>
        public int Y;

        /// <summary>
        ///     Returns a string that represents the current object.
        /// </summary>
        /// <returns>A <see cref="System.String" /> that represents this instance.</returns>
        public override string ToString()
        {
            return $"X = {X} Y = {Y}";
        }
    }

    /// <summary>
    ///     Structure containing basic information about a process.
    /// </summary>
    public struct ProcessBasicInformation
    {
        /// <summary>
        ///     The affinity mask.
        /// </summary>
        public uint AffinityMask;

        /// <summary>
        ///     The base priority.
        /// </summary>
        public uint BasePriority;

        /// <summary>
        ///     The exit status.
        /// </summary>
        public IntPtr ExitStatus;

        /// <summary>
        ///     The process id of the parent process.
        /// </summary>
        public int InheritedFromUniqueProcessId;

        /// <summary>
        ///     The base address of ProcessUpdateData Environment Block.
        /// </summary>
        public IntPtr PebBaseAddress;

        /// <summary>
        ///     The process id.
        /// </summary>
        public int ProcessId;

        /// <summary>
        ///     The size of this structure.
        /// </summary>
        public int Size => RemoteMarshal<ProcessBasicInformation>.Size;
    }

    /// <summary>
    ///     Structure containing basic information about a thread.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct ThreadBasicInformation
    {
        /// <summary>
        ///     The affinity mask.
        /// </summary>
        public uint AffinityMask;

        /// <summary>
        ///     The base priority.
        /// </summary>
        public uint BasePriority;

        /// <summary>
        ///     the exit status.
        /// </summary>
        public uint ExitStatus;

        /// <summary>
        ///     The priority.
        /// </summary>
        public uint Priority;

        /// <summary>
        ///     The process id which owns the thread.
        /// </summary>
        public int ProcessId;

        /// <summary>
        ///     The base address of Thread Environment Block.
        /// </summary>
        public IntPtr TebBaseAdress;

        /// <summary>
        ///     The thread id.
        /// </summary>
        public int ThreadId;
    }

    /// <summary>
    ///     Represents a thread context.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct ThreadContext
    {
        /// <summary>
        ///     Determines which registers are returned or set when using <see cref="SafeNativeMethods.GetThreadContext" /> or
        ///     <see cref="SafeNativeMethods.SetThreadContext" />.
        ///     If the context record is used as an INPUT parameter, then for each portion of the context record controlled by a
        ///     flag whose value is set, it is assumed that portion of the
        ///     context record contains valid context. If the context record is being used to modify a threads context, then only
        ///     that portion of the threads context will be modified.
        ///     If the context record is used as an INPUT/OUTPUT parameter to capture the context of a thread, then only those
        ///     portions of the thread's context corresponding to set flags will be returned.
        ///     The context record is never used as an OUTPUT only parameter.
        /// </summary>
        public ThreadContextFlags ContextFlags;

        /// <summary>
        ///     This is specified/returned if <see cref="ContextFlags" /> contains the flag
        ///     <see cref="ThreadContextFlags.DebugRegisters" />.
        /// </summary>
        public uint Dr0;

        /// <summary>
        ///     This is specified/returned if <see cref="ContextFlags" /> contains the flag
        ///     <see cref="ThreadContextFlags.DebugRegisters" />.
        /// </summary>
        public uint Dr1;

        /// <summary>
        ///     This is specified/returned if <see cref="ContextFlags" /> contains the flag
        ///     <see cref="ThreadContextFlags.DebugRegisters" />.
        /// </summary>
        public uint Dr2;

        /// <summary>
        ///     This is specified/returned if <see cref="ContextFlags" /> contains the flag
        ///     <see cref="ThreadContextFlags.DebugRegisters" />.
        /// </summary>
        public uint Dr3;

        /// <summary>
        ///     This is specified/returned if <see cref="ContextFlags" /> contains the flag
        ///     <see cref="ThreadContextFlags.DebugRegisters" />.
        /// </summary>
        public uint Dr6;

        /// <summary>
        ///     This is specified/returned if <see cref="ContextFlags" /> contains the flag
        ///     <see cref="ThreadContextFlags.DebugRegisters" />.
        /// </summary>
        public uint Dr7;

        /// <summary>
        ///     This register is specified/returned if the ContextFlags word contains the flag
        ///     <see cref="ThreadContextFlags.Integer" />.
        /// </summary>
        public uint Eax;

        /// <summary>
        ///     This is specified/returned if <see cref="ContextFlags" /> contains the flag
        ///     <see cref="ThreadContextFlags.Control" />.
        /// </summary>
        public uint Ebp;

        /// <summary>
        ///     This register is specified/returned if the ContextFlags word contains the flag
        ///     <see cref="ThreadContextFlags.Integer" />.
        /// </summary>
        public uint Ebx;

        /// <summary>
        ///     This register is specified/returned if the ContextFlags word contains the flag
        ///     <see cref="ThreadContextFlags.Integer" />.
        /// </summary>
        public uint Ecx;

        /// <summary>
        ///     This register is specified/returned if the ContextFlags word contains the flag
        ///     <see cref="ThreadContextFlags.Integer" />.
        /// </summary>
        public uint Edi;

        /// <summary>
        ///     This register is specified/returned if the ContextFlags word contains the flag
        ///     <see cref="ThreadContextFlags.Integer" />.
        /// </summary>
        public uint Edx;

        /// <summary>
        ///     This is specified/returned if <see cref="ContextFlags" /> contains the flag
        ///     <see cref="ThreadContextFlags.Control" />.
        /// </summary>
        public uint EFlags;

        /// <summary>
        ///     This is specified/returned if <see cref="ContextFlags" /> contains the flag
        ///     <see cref="ThreadContextFlags.Control" />.
        /// </summary>
        public uint Eip;

        /// <summary>
        ///     This register is specified/returned if the ContextFlags word contains the flag
        ///     <see cref="ThreadContextFlags.Integer" />.
        /// </summary>
        public uint Esi;

        /// <summary>
        ///     This is specified/returned if <see cref="ContextFlags" /> contains the flag
        ///     <see cref="ThreadContextFlags.Control" />.
        /// </summary>
        public uint Esp;

        /// <summary>
        ///     This is specified/returned if <see cref="ContextFlags" /> contains the flag
        ///     <see cref="ThreadContextFlags.ExtendedRegisters" />.
        ///     The format and contexts are processor specific.
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 512)] public byte[] ExtendedRegisters;

        /// <summary>
        ///     This is specified/returned if <see cref="ContextFlags" /> contains the flag
        ///     <see cref="ThreadContextFlags.FloatingPoint" />.
        /// </summary>
        [MarshalAs(UnmanagedType.Struct)] public FloatingSaveArea FloatingSave;

        /// <summary>
        ///     This is specified/returned if <see cref="ContextFlags" /> contains the flag
        ///     <see cref="ThreadContextFlags.Control" />.
        /// </summary>
        public uint SegCs;

        /// <summary>
        ///     This is specified/returned if <see cref="ContextFlags" /> contains the flag
        ///     <see cref="ThreadContextFlags.Segments" />.
        /// </summary>
        public uint SegDs;

        /// <summary>
        ///     This is specified/returned if <see cref="ContextFlags" /> contains the flag
        ///     <see cref="ThreadContextFlags.Segments" />.
        /// </summary>
        public uint SegEs;

        /// <summary>
        ///     This is specified/returned if <see cref="ContextFlags" /> contains the flag
        ///     <see cref="ThreadContextFlags.Segments" />.
        /// </summary>
        public uint SegFs;

        /// <summary>
        ///     This is specified/returned if <see cref="ContextFlags" /> contains the flag
        ///     <see cref="ThreadContextFlags.Segments" />.
        /// </summary>
        public uint SegGs;

        /// <summary>
        ///     This is specified/returned if <see cref="ContextFlags" /> contains the flag
        ///     <see cref="ThreadContextFlags.Control" />.
        /// </summary>
        public uint SegSs;
    }

    /// <summary>
    ///     Returned if <see cref="ThreadContextFlags.FloatingPoint" /> flag is set.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct FloatingSaveArea
    {
        /// <summary>
        ///     The control word{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public uint ControlWord;

        /// <summary>
        ///     The CR0 NPX state{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public uint Cr0NpxState;

        /// <summary>
        ///     The data offset{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public uint DataOffset;

        /// <summary>
        ///     The data selector{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public uint DataSelector;

        /// <summary>
        ///     The error offset{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public uint ErrorOffset;

        /// <summary>
        ///     The error selector{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public uint ErrorSelector;

        /// <summary>
        ///     The register area{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 80)] public byte[] RegisterArea;

        /// <summary>
        ///     The status word{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public uint StatusWord;

        /// <summary>
        ///     The tag word{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public uint TagWord;
    }

    /// <summary>
    ///     The <see cref="Rectangle" /> structure defines the coordinates of the upper-left and lower-right corners of a
    ///     rectangle.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct Rectangle
    {
        /// <summary>
        ///     The y-coordinate of the lower-right corner of the rectangle.
        /// </summary>
        public int Bottom;

        /// <summary>
        ///     The x-coordinate of the upper-left corner of the rectangle.
        /// </summary>
        public int Left;

        /// <summary>
        ///     The x-coordinate of the lower-right corner of the rectangle.
        /// </summary>
        public int Right;

        /// <summary>
        ///     The y-coordinate of the upper-left corner of the rectangle.
        /// </summary>
        public int Top;

        /// <summary>
        ///     Gets or sets the height of the element.
        /// </summary>
        public int Height
        {
            get { return Bottom - Top; }
            set { Bottom = Top + value; }
        }

        /// <summary>
        ///     Gets or sets the width of the element.
        /// </summary>
        public int Width
        {
            get { return Right - Left; }
            set { Right = Left + value; }
        }

        /// <summary>
        ///     Returns a string that represents the current object.
        /// </summary>
        public override string ToString()
        {
            return $"Left = {Left} Top = {Top} Height = {Height} Width = {Width}";
        }
    }

    /// <summary>
    ///     Contains information about the placement of a window on the screen.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct WindowPlacement
    {
        /// <summary>
        ///     Specifies flags that control the position of the minimized window and the method by which the window is restored.
        /// </summary>
        public int Flags;

        /// <summary>
        ///     The length of the structure, in bytes. Before calling the GetWindowPlacement or SetWindowPlacement functions, set
        ///     this member to sizeof(WINDOWPLACEMENT).
        /// </summary>
        public int Length;

        /// <summary>
        ///     The coordinates of the window's upper-left corner when the window is maximized.
        /// </summary>
        public Point MaxPosition;

        /// <summary>
        ///     The coordinates of the window's upper-left corner when the window is minimized.
        /// </summary>
        public Point MinPosition;

        /// <summary>
        ///     The window's coordinates when the window is in the restored position.
        /// </summary>
        public Rectangle NormalPosition;

        /// <summary>
        ///     The current show state of the window.
        /// </summary>
        public WindowStates ShowCmd;
    }

    /// <summary>
    ///     Contains information about a x64 bit Peb.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct Peb64
    {
        /// <summary>
        ///     The being debugged{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public byte BeingDebugged;

        /// <summary>
        ///     The image base{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public IntPtr ImageBase;

        /// <summary>
        ///     The inherited address space{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public byte InheritedAddressSpace;

        /// <summary>
        ///     The p LDR{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public IntPtr pLdr;

        /// <summary>
        ///     The p mutant{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public IntPtr pMutant;

        /// <summary>
        ///     The read image file execute options{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public byte ReadImageFileExecOptions;

        /// <summary>
        ///     The spare bool{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public byte SpareBool;
    }

    /// <summary>
    ///     Struct for a basic list entry.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct ListEntry
    {
        /// <summary>
        ///     The b link{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public IntPtr BLink;

        /// <summary>
        ///     The f link{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public IntPtr FLink;
    }

    /// <summary>
    ///     Struct containing data about Ldr peb data for 64 bit.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct PebLdrData64
    {
        /// <summary>
        ///     The entry in progress{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public IntPtr EntryInProgress;

        /// <summary>
        ///     The in initialization order module list{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public ListEntry InInitializationOrderModuleList;

        /// <summary>
        ///     The initialized{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public byte Initialized;

        /// <summary>
        ///     The in load order module list{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public ListEntry InLoadOrderModuleList;

        /// <summary>
        ///     The in memory order module list{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public ListEntry InMemoryOrderModuleList;

        /// <summary>
        ///     The length{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public int Length;

        /// <summary>
        ///     The ss handle{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public IntPtr SsHandle;
    }

    /// <summary>
    ///     Struct LdrDataTableEntry64 containins data about an entry from the Ldr structure table.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct LdrDataTableEntry64
    {
        /// <summary>
        ///     The base DLL name{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public UnicodeString BaseDllName;

        /// <summary>
        ///     The check sum{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public uint CheckSum;

        /// <summary>
        ///     The DLL base{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public IntPtr DllBase;

        /// <summary>
        ///     The entry point{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public IntPtr EntryPoint;

        /// <summary>
        ///     The entry point activation context{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public IntPtr EntryPointActivationContext;

        /// <summary>
        ///     The flags{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public uint Flags;

        /// <summary>
        ///     The full DLL name{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public UnicodeString FullDllName;

        /// <summary>
        ///     The in initialization order module list{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public ListEntry InInitializationOrderModuleList;

        /// <summary>
        ///     The in load order module list{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public ListEntry InLoadOrderModuleList;

        /// <summary>
        ///     The in memory order module list{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public ListEntry InMemoryOrderModuleList;

        /// <summary>
        ///     The load count{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public short LoadCount;

        /// <summary>
        ///     The loaded imports{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public IntPtr LoadedImports;

        /// <summary>
        ///     The patch information{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public IntPtr PatchInformation;

        /// <summary>
        ///     The section pointer{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public IntPtr SectionPointer;

        /// <summary>
        ///     The size of image{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public int SizeOfImage;

        /// <summary>
        ///     The TLS index{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public short TlsIndex;
    }

    /// <summary>
    ///     Struct for marsahling unicode strings.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct UnicodeString : IDisposable
    {
        /// <summary>
        ///     The buffer{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public IntPtr Buffer;

        /// <summary>
        ///     The length{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public ushort Length;

        /// <summary>
        ///     The maximum length{CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
        /// </summary>
        public ushort MaximumLength;

        /// <summary>
        ///     Initializes a new instance of the <see cref="UnicodeString" /> struct.
        /// </summary>
        /// <param name="s">The s.</param>
        public UnicodeString(string s = null)
        {
            if (s != null)
            {
                Length = (ushort) (s.Length*2);
                MaximumLength = (ushort) (Length + 2);
                Buffer = Marshal.StringToHGlobalUni(s);
            }
            else
            {
                Length = 0;
                MaximumLength = 0;
                Buffer = IntPtr.Zero;
            }
        }

        /// <summary>
        ///     Disposes this instance.
        /// </summary>
        public void Dispose()
        {
            if (Buffer != IntPtr.Zero) Marshal.FreeHGlobal(Buffer);
            Buffer = IntPtr.Zero;
        }

        /// <summary>
        ///     To the string.
        /// </summary>
        /// <returns>System.String.</returns>
        public override string ToString()
        {
            // ReSharper disable once AssignNullToNotNullAttribute
            return Buffer != IntPtr.Zero ? Marshal.PtrToStringUni(Buffer) : string.Empty;
        }
    }
}